from pytest import approxfrom quantipy import base# TODO: test reverse computations# Length classdef test_length_init():    test = base.Length()    assert test._meter == None    assert test._foot == None    def test_length_nonattr():    length = base.Length()    try:        length.kg = 6    except TypeError:        assert True    else:        assert False    def test_set_m():    test = base.Length()    test_values = [0,     1,     -1,     3.14,     -1000,     1e10]        ft_ans = [0, 3.280839895013123, -3.280839895013123, 10.301837270341206,               -3280.839895013123, 32808398950.13123,]        km_ans = [0, 0.001, -0.001, 0.00314, -1, 1e7]                   nmi_ans = [0, 0.0005399568034557236, -0.0005399568034557236,               0.0016954643628509722, -0.5399568034557236, 5399568.034557236]        for i, item in enumerate(test_values):        test.m = item        print(i)        assert test.ft == approx(ft_ans[i])        assert test.km == km_ans[i]        assert test.nmi == approx(nmi_ans[i])        def test_ft_in():    ft = 5    inch = 12        height = base.Length()    height.ft_in = (ft, inch)        assert height.ft == 6def test_length_add():    l1 = base.Length()    l2 = base.Length()    l1.m = 5    l2.m = 6    assert (l1 + l2).m == 11    def test_length_sub():    l1 = base.Length()    l2 = base.Length()    l1.m = 5    l2.m = 6    assert (l1 - l2).m == -1    def test_length_mul():    l1 = base.Length()    l2 = base.Length()    l1.m = 5    l2.m = 6    assert (l1 * 4).m == 20    assert (4 * l1).m == 20        try:        l1 * l2    except TypeError:        assert True    else:        assert False        def test_length_div():    l1 = base.Length()    l2 = base.Length()    l1.m = 3    l2.m = 6    assert (l1 / 6).m == 0.5    assert l1 / l2 == 0.5    def test_length_floordiv():    l1 = base.Length()    l2 = base.Length()    l1.m = 3    l2.m = 6.5    assert (l1 // 2).m == 1    assert (l2 // l1) == 2    # Mass classdef test_mass_init():    test = base.Mass()    assert test._kilogram == None    assert test._pound == None    def test_mass_nonattr():    mass = base.Mass()    try:        mass.ft = 6    except TypeError:        assert True    else:        assert False    def test_set_kg():    test = base.Mass()    test_values = [0,     1,     -1,     3.14,     -1000,     1e10]        lb_ans = [0, 2.2046226218487757, -2.2046226218487757, 6.922515032605156,               -2204.6226218487757, 22046226218.487757,]        g_ans = [0, 1000, -1000, 3140, -1e6, 1e13]        oz_ans = [0, 35.27396194958041, -35.27396194958041, 110.76024052168249,              -35273.96194958041, 352739619495.8041]            t_uk_ans = []        t_us_ans = []        t_si_ans = []        for i, item in enumerate(test_values):        test.kg = item        print(i)        assert test.lb == approx(lb_ans[i])        assert test.g == g_ans[i]        assert test.oz == approx(oz_ans[i])            test.lb = 2240    assert test.t_uk == 1    test.lb = 2000    assert test.t_us == 1    test.kg = 1000    assert test.t_si == 1def test_mass_add():    m1 = base.Mass()    m2 = base.Mass()    m1.kg = 5    m2.kg = 6    assert (m1 + m2).kg == 11    def test_mass_sub():    m1 = base.Mass()    m2 = base.Mass()    m1.kg = 5    m2.kg = 6    assert (m1 - m2).kg == -1    def test_mass_mul():    m1 = base.Mass()    m2 = base.Mass()    m1.kg = 5    m2.kg = 6    assert (m1 * 4).kg == 20    assert (4 * m1).kg == 20        try:        m1 * m2    except TypeError:        assert True    else:        assert False        def test_mass_div():    m1 = base.Mass()    m2 = base.Mass()    m1.kg = 3    m2.kg = 6    assert (m1 / 6).kg == 0.5    assert m1 / m2 == 0.5    def test_mass_floordiv():    m1 = base.Mass()    m2 = base.Mass()    m1.kg = 3    m2.kg = 6.5    assert (m1 // 2).kg == 1    assert (m2 // m1) == 2    # Time classdef test_time_init():    test = base.Length()    assert test._meter == None    assert test._foot == None    def test_time_nonattr():    time_var = base.Time()    try:        time_var.kg = 6    except TypeError:        assert True    else:        assert False    def test_set_s():    test = base.Time()    test_values = [0,     1,     -1,     120,     7200,     86400]        minutes_ans = [0, 0.016666666666666666, -0.016666666666666666,                   2, 120, 1440]        h_ans = [0, 0.0002777777777777778, -0.0002777777777777778,               0.03333333333333333, 2, 24]                   d_ans = [0, 1.1574074074074073e-05, -1.1574074074074073e-05,             0.001388888888888889, 0.08333333333333333, 1]        for i, item in enumerate(test_values):        test.s = item        print(i)        assert test.minute == approx(minutes_ans[i])        assert test.h == h_ans[i]        assert test.d == approx(d_ans[i])        def test_hms():    h = 1    m = 1    s = 1000        time_var = base.Time()    time_var.hms = (h, m, s)        assert time_var.s == 3600 + 60 + 1000def test_time_add():    t1 = base.Time()    t2 = base.Time()    t1.s = 5    t2.s = 6    assert (t1 + t2).s == 11    def test_time_sub():    t1 = base.Time()    t2 = base.Time()    t1.s = 5    t2.s = 6    assert (t1 - t2).s == -1    def test_time_mul():    t1 = base.Time()    t2 = base.Time()    t1.s = 5    t2.s = 6    assert (t1 * 4).s == 20    assert (4 * t1).s == 20        try:        t1 * t2    except TypeError:        assert True    else:        assert False        def test_time_div():    t1 = base.Time()    t2 = base.Time()    t1.s = 3    t2.s = 6    assert (t1 / 6).s == 0.5    assert t1 / t2 == 0.5    def test_time_floordiv():    t1 = base.Time()    t2 = base.Time()    t1.s = 3    t2.s = 6.5    assert (t1 // 2).s == 1    assert (t2 // t1) == 2